IPFフォーマット解説

===============
IPFファイルはZipなどと同じように複数のファイルをひとまとめにした圧縮ファイルみたいなもんです。
そんなに難しくはないです。構造としては次のようになっています。

+----------------+ ファイル先頭
|file data 0     |
|...             |
+----------------+
|file data n     |
|...             |
+----------------+
|ipf info 0      | ファイル0の情報
+----------------+
|ipf info n      | ファイルnの情報
+----------------+
|ipf header      | ヘッダ
+----------------+ ファイル終端

大まかにみると、ファイル自体のヘッダはファイルの最後に書かれています。
なのでファイル先頭をいきなり解読しようと努力しても？？？となります。


IPFヘッダの構造
===============

IPFファイルのヘッダはこんな構造です。

+----------------------------------+ 
| IPFに含まれる総ファイル数        | 16Byte
+----------------------------------+ 
| IPF情報テーブルへのファイル位置  | 32Byte
+----------------------------------+ 
| 不明                             | 16Byte
+----------------------------------+ 
| このヘッダのファイル位置         | 32Byte
+----------------------------------+ 
| フォーマット                     | 32Byte
+----------------------------------+ 
| ベースリビジョン                 | 32Byte
+----------------------------------+ 
| リビジョン                       | 32Byte
+----------------------------------+ 

IPFに含まれる総ファイル数は、そのままの通りでこのIPFに含まれるファイルの総数です。

IPF情報テーブルへのファイル位置は、後述するIPF内の各ファイル情報がまとまったテーブルへのIPFファイル先頭からの位置です。
seekなんかでシークしていけばいいでしょう。

不明はよくわかりません。大抵0が入ってます。

このヘッダのファイル位置はIPFヘッダへのIPFファイル先頭からの位置です。
そもそもこれが読める時点でこの情報は要らない気がするけどなんでやろね

フォーマットはこのIPFはどんな形式かを示します。今のところ0x06054B50となっとります。
ビックエンディアンに直すと50 4B 05 06となり、PKとなります。要するにPKZipぽいということなんですかね。
つまり、これ以外の値が入ってたらIPFテーブル情報の値が信用できなくなるので、弾いたほうがよさげです。

ベースリビジョンはよくわかりません。ファイルフォーマットの変更に関わることではなく、このIPFファイルそのもののバージョンとかそういったものかと思います。
リビジョンはパッチファイルで使うらしく、リビジョンとパッチのファイル名が一致しています。
これはtos.exe(パッチダウンローダ)が参照するらしく、release/release.revision.txtとも関連しています。
(例: 136528_001001.ipf の場合は136528がリビジョン番号で最後に当たったパッチのリビジョンがrelease.revision.txtに書かれる仕組みの様子)


構造が4バイトバウンタリではなく思いっきり16Byte-32-16-32と来てしまってるので、Cで表現するときはpragma pack push1-pop1で挟んで隙間をなくしておかないとfreadなんかで構造体をまとめて読むときに思いっきりズレます。誰だこんなフォーマット考えたのは。。。



IPF情報テーブルの構造
===============

IPF情報テーブルはこんな構造です。
ヘッダの「IPF情報テーブルへのファイル位置」からseekして読むのが良いでしょう。

+----------------------------------+ 
| ファイル名の長さ                 | 16Byte
+----------------------------------+ 
| ファイルデータのCRC値            | 32Byte
+----------------------------------+ 
| 圧縮後のサイズ                   | 32Byte
+----------------------------------+ 
| 圧縮前のサイズ                   | 32Byte
+----------------------------------+ 
| データへのファイル位置           | 32Byte
+----------------------------------+ 
| アーカイブ名の長さ               | 16Byte
+----------------------------------+ 
| アーカイブ名文字列               | アーカイブ名の長さByte
+----------------------------------+ 
| ファイル名文字列                 | ファイル名の長さByte
+----------------------------------+ 
…ヘッダの総ファイル数になるまで繰り返し
+----------------------------------+ 


ファイル名の長さ、アーカイブ名の長さはそれぞれファイル名、アーカイブ名のバイト数です。
\0(Null文字)は含まれないので注意

圧縮前・後サイズは、データ本体の圧縮前、後サイズになります。
データには圧縮されていないもの、圧縮されているものがあります。この辺はまた後程…

CRC値は圧縮前ファイルデータのCRC32値です。
CRC値を調べることによって解凍したファイルが壊れてないかどうかなどをチェックできます

データへのファイル位置は、ファイル先頭からこのファイルのデータが格納されているオフセット値です。
そのままseekすると読めます。

後ろのアーカイブ文字列は、「addon.ipf」などの文字列が入ります。
ファイル名文字列は、「sysmenu/sysmenu.lua」などの文字列が入ります。

ToSのファイル階層はおおむね次のような感じになっています。

/ --- addon.ipf 
  |      |
  |      +---- sysmenu --+--- sysmenu.lua
  |                      |--- susmenu.xml
  |                        ...
  |
  --- jp.ipf
        |
        +---- aaaaa   ---- bbbb.lua


この場合、アーカイブ文字列は[addon.ipf]やら[jp.ipf]等であり、大まかな分類がなされています。
TosのDataに入っているのは1:1ですが、patchは上記のように複数のアーカイブが含まれていることもあります。
そうじゃないとパッチにならんしね

ファイル名文字列は各アーカイブ配下のディレクトリとそのファイル名になってます。
ディレクトリはWindows形式のバックスラッシュ(\)ではなく何故かLinuxやMac形式なスラッシュ(/)なので
この辺りコード書くときに気を付けるべき点ですな


各ファイルデータ
===============

いよいよ各ファイルのデータですが、データは暗号化が掛かっていてさらにZip形式で圧縮されています。
暗号化されているかどうかは拡張子によって変わります。

但し、JpgやMP3、FSB(スキルのボイスなんかをこれで格納してる。WoTで使われているとか…)ファイルは
圧縮の対象外みたいです。なので当ライブラリもそのようにしています。

まあこの辺は、圧縮したところであまりサイズかわんなさそうやし、結果、ローディング時間長くなるだけやしね

当ライブラリは、最初は圧縮前＝後だったら対象外にしてたのですが、圧縮前と後が一緒になるパターンがでたので
泣く泣く拡張子判定に変えました。

ただ、なんかしらんけどpngも圧縮しようとしてたりして、結局元ファイルより圧縮後サイズのほうがでかくなってる
のも散見されるのでなんか適当なもんやなあと…


で、圧縮の流れが
1.元データをZipで圧縮
2.それを暗号化

という流れになってるので、解凍するには
1.復号
2.Zipで解凍
という感じになります。

暗号化そのものの処理は、Zipの暗号化のアルゴリズムを若干改変して使ってます。
暗号の鍵は"ofO1a0ueXA? [\xFFs h %?"であり(\xFFは0xFFです。文字じゃないです)、これをZipの暗号化
アルゴリズムに鍵として暗号化してます。

若干Zip暗号のオリジナルと改変しているというのは、元データすべてを暗号化しているわけではなく
1Byteおきにとびとびに暗号化がかかっとるというところですな。

尚、暗号化→復号化してもサイズは変わらないので、とびとびになってる様は暗号化前と後の数列を見比べてみる
とよくわかります。すぐばれるのにこんなことして意味あるんけ？

ちなみに暗号化を二回やると復号となります。（Xorみたいなもん）

復号した後でデータをZipアルゴリズムに基づいて解凍してやるとやっと生データを取ることができます。
生データはとりあえずCRC値を見て正しいかどうか検証したほうがええねそやね。


圧縮について
===============

時々解凍後サイズ0のファイル(つまり空のファイル)があります。
解凍や圧縮の際はこれにちょっと気を付けないといけません。

当ライブラリは0x7D,0x00を書き込むことにしています。
また、CRC値は0になります。

これは元のIPFファイルがそうだったため仕様を合わせています。



雑感
===============

仕様的にパッチが多くなればなるほどMap移動時のロードが遅くなるんちゃうかなと
アップデータがとりあえず解凍してどこかに共有メモリとして置いとるのかもしれんけど。
その辺はまだ見てないのでなんとも。

PNGにZip圧縮をわざわざかけてるのはコンボイ級の謎
Zip圧縮をかけるのはLuaスクリプトとかxmlとかああいうテキストだけにしとけとか思うね。
データにやってもあまり意味が薄いで。

もしくはIPF作成時に圧縮前＜圧縮後やったら圧縮しないとかあるやろと…
ローディング時間の短縮になるのにねなんでやらんのやろね



